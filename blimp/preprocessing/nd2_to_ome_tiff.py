"""
Copyright 2022 (C) University of New South Wales
Original author:
Scott Berry <scott.berry@unsw.edu.au>
"""
import os
import logging
import numpy as np
from glob import glob
from pathlib import Path
from typing import Union
from nd2reader import ND2Reader
from aicsimageio.writers import OmeTiffWriter
from aicsimageio.types import PhysicalPixelSizes
from blimp.utils import init_logging, VERBOSITY_TO_LEVELS
from blimp.preprocessing.nd2_parse_metadata import nd2_extract_metadata_and_save

log = logging.getLogger("nd2_to_ome_tiff")


def convert_individual_nd2_to_ome_tiff(
    in_file_path : Union[str,Path],
    out_path : Union[str,Path],
    out_path_mip : Union[str,Path]=None):
    """
    Reads an nd2 file and writes a set of image files corresponding
    to single imaging sites (field of view).

    Parameters
    ----------
    in_file_path
        Full path to the .nd2 image file
    out_path
        Full path to the folder for OME-TIFFs
    out_path_mips
        Full path to the folder z-projected OME-TIFFs
    Returns
    -------

    """

    log.info('Reading individual ND2 file {}'.format(in_file_path))
    images = ND2Reader(str(in_file_path))

    log.info('Saving metadata for {} in {}'.format(in_file_path, out_path))
    nd2_metadata = nd2_extract_metadata_and_save(in_file_path,out_path)

    # save mip metadata
    if (out_path_mip is not None):
        log.info('Saving MIP metadata for {} in {}'.format(in_file_path,out_path_mip))
        nd2_metadata = nd2_extract_metadata_and_save(in_file_path,out_path_mip,mip=True)

    n_sites = images.sizes['v']
    
    images.bundle_axes = 'tczyx'
    images.iter_axes = 'v'
 
    for i, img in enumerate(images):
        
        out_file_path = Path(out_path) / Path(Path(in_file_path).stem + '_' + str(i+1).zfill(4) +'.ome.tiff')
        
        voxel_dimensions = _get_zyx_resolution(img.metadata)
        
        log.debug('Writing OME-TIFF, field-of-view #{}'.format(i))
        OmeTiffWriter.save(
            data = img,
            uri = out_file_path,
            dim_order="TCZYX",
            channel_names=img.metadata['channels'],
            physical_pixel_sizes=voxel_dimensions,
            parser='lxml')
        
        if (out_path_mip is not None):
            
            out_file_path_mip = Path(out_path_mip) / Path(Path(in_file_path).stem + '_' + str(i+1).zfill(4) +'.ome.tiff')
            
            log.debug('Writing OME-TIFF MIP, field-of-view #{}'.format(i))
            OmeTiffWriter.save(
                data = np.max(img,axis=2,keepdims=True),
                uri = out_file_path_mip,
                dim_order="TCZYX",
                channel_names=img.metadata['channels'],
                physical_pixel_sizes=voxel_dimensions,
                parser='lxml')
    
    return(out_file_path)


def _get_zyx_resolution(
    image_metadata : dict) -> PhysicalPixelSizes:
    """
    Determines the z,y,x resolution from the metadata

    Parameters
    ----------
    image_metadata
        Metadata dict generated by ND2Reader

    Returns
    -------
    PhysicalPixelSizes
        AICSImage object for containing pixel dimensions
    """
    log.debug('Getting voxel dimensions')
    xy = image_metadata['pixel_microns']
    n_z = 1 + max([i for i in image_metadata['z_levels']])
    return(PhysicalPixelSizes(Z=(max(image_metadata['z_coordinates'][0:n_z]) - 
                                 min(image_metadata['z_coordinates'][0:n_z])) / (n_z - 1),
                              Y=image_metadata['pixel_microns'],
                              X=image_metadata['pixel_microns']))

def _get_list_of_files_current_batch(
    in_path : Union[str,Path],
    batch_id : int,
    n_batches : int) -> list:
    """
    Get a list of files to process in batch mode

    Parameters
    ----------
    in_path
        Full path to the folder of .nd2 image files
    batch_id
        0-indexed batch id
    n_batches
        How many batches the files should be processed in

    Returns
    -------
    List[str]
        list of files to process in this batch
    """

    batch_id = int(batch_id)
    n_batches = int(n_batches)

    # get reproducible list of nd2 files in 'in_path'
    filepaths = glob(str(in_path / "*.nd2"))
    filepaths.sort()
    log.debug("{} files found:".format(len(filepaths)))
    for i, f in enumerate(filepaths):
        log.debug("Input file {}: {}".format(i,f))

    n_files_per_batch = int(np.ceil(float(len(filepaths)) / float(n_batches)))

    log.info("Splitting nd2 file list into {} batches of size {}".format(n_batches,n_files_per_batch))
    log.info("Processing batch {}".format(batch_id))

    return(filepaths[
        batch_id * n_files_per_batch:
        (batch_id+1) * n_files_per_batch])


def nd2_to_ome_tiff(
    in_path : Union[str,Path],
    out_path : Union[str,Path],
    n_batches : int=1,
    batch_id : int=0,
    mip : bool=False) -> None:
    """
    Reads an folder of nd2 files and converts to OME-TIFFs. 
    Can perform batch processing.

    Parameters
    ----------
    in_path
        Full path to the folder of .nd2 image files
    out_path
        Full path to the folder for OME-TIFFs
    n_batches
        number of batches into which the processing should be split.
    batch_id
        current batch to process
    mip
        whether to save maximum-intensity-projections

    Returns
    -------

    """

    # setup paths
    in_path = Path(in_path)
    out_path = Path(out_path)
    if mip:
        out_path_mip = out_path.parent / (str(out_path.stem) + '-MIP')
    else:
        out_path_mip = None
    
    if in_path==out_path:
        log.error("Input and output paths are the same.")
        os._exit(1)

    # make output directories
    if not out_path.exists():
        log.info("Created output directory: {}".format(out_path))
        out_path.mkdir(parents=True, exist_ok=True)
    if mip and not out_path_mip.exists():
        log.info("Created output directory: {}".format(out_path_mip))
        out_path_mip.mkdir(parents=True, exist_ok=True)

    # get list of files to process
    filename_list = _get_list_of_files_current_batch(
        in_path=in_path,
        n_batches=n_batches,
        batch_id=batch_id)

    log.info("Converting nd2 files: {}".format(filename_list))
    for f in filename_list:
        convert_individual_nd2_to_ome_tiff(
            in_file_path=in_path / f,
            out_path=out_path,
            out_path_mip=out_path_mip,
        )

    return()


if __name__ == "__main__":
    from argparse import ArgumentParser

    parser = ArgumentParser(prog="nd2_to_ome_tiff")

    parser.add_argument(
        "-i",
        "--in_path",
        help="directory containing the input files",
        required=True
    )

    parser.add_argument(
        "-o",
        "--out_path",
        help="directory to write the output files",
        required=True
    )

    parser.add_argument(
        "--image_format",
        default="TIFF",
        help="output format for images (currently only TIFF implemented)"
    )

        
    parser.add_argument(
        "--batch",
        nargs=2,
        default=[1,0],
        help="""
            If files are processed as batches, provide the number of 
            batches and the current batch to be processed. Batches
            refer to the number of sites (fields-of-view) and batch
            numbers start at 0.
        """
    )

    parser.add_argument(
        "-m", "--mip",
        default=False,
        action="store_true",
        help="whether to save maximum intensity projections"
    )

    parser.add_argument('-v', '--verbose', action='count', default=0,
    help="Increase verbosity (e.g. -vvv)")
    args = parser.parse_args()

    init_logging(VERBOSITY_TO_LEVELS[args.verbose])

    nd2_to_ome_tiff(
        in_path=args.in_path,
        out_path=args.out_path,
        n_batches=args.batch[0],
        batch_id=args.batch[1],
        mip=args.mip
    )

